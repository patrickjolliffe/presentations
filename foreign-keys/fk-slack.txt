Foreign Keys
As I’ve mentioned to some, I’m thinking about building a presentation on Foreign Keys.
The idea came from @Toon Koppelaars presentation on db constraints — his assertion (simplified) that understanding FKs is the key to understanding the DB constrains. Sure I pretend that I understand everything about FKs, but really I don't.
I've heard that building a decent presentation is a lot of work, so I’m hoping to outsource a bit here...
   Anything interesting you know about FKs that maybe not everyone does
   Any questions you have (“how does Oracle handle this?” / “what happens in this situation?”)
Not promising I’ll actually put the presentation together — and if someone else wants to do it, I’ll happily just sit in the audience and learn.
12 replies


Oren Nakdimon
  Sep 17th at 10:52 AM
Patrick, if it helps, perhaps you'll find some relevant stuff in the Constraint Creation Optimization series in my blog.
Part 3 is specifically about optimizing the creation of a FK when it's created in the same DDL as the base column addition.
Part 6 is about creating FKs (and also check constraints) in an online way.
@DBoriented@DBoriented
Constraint Creation Optimization - @DBoriented
This is an index to a series of posts I have been writing about optimization techniques that the Oracle database applies, or not, while adding constraints to tables: Part 1: Optimization of Check Constraint Creation Part 2: Optimization that Violates Data Integrity Part 3: Optimization of Foreign Key Constraint Creation Part 4: (Lack of) Optimization … Continue reading "Constraint Creation Optimization"
Est. reading time
1 minute
:pray:
1



Oren Nakdimon
  Sep 17th at 11:05 AM
And if you're after slides, there is my The Difference a Comma Can Make presentation, that is based on that blog post series (plus some additional stuff).
I hope that helps.
SlideShareSlideShare
Constraint Optimization
This document discusses constraint optimization in SQL, covering various types of constraints (inline, out-of-line) and their creation syntax. It highlights the importance of understanding constraints for effective database management, providing examples and guidelines for implementation. Additionally, it includes insights into validating constraint states and the implications of enabling/disabling constraints on data integrity. - Download as a PDF or view online for free
https://www.slideshare.net/slideshow/constraint-optimization/184754344

:pray:
1
:+1:
1

Jasmin Fluri
  Sep 17th at 11:40 AM
Maybe a side topic:
When I talk about modelling in workshops or on-site at the customer I usually stick to the premise that we label relations with 0 ... m or 1 ... m
So far I think it doesn't make a difference in how the foreign key is created. It's just an additional information on our ERD. Would be interesting if this assumtion is true....

Patrick Jolliffe
  Sep 17th at 11:58 AM
not entirely sure i understand you @Jasmin Fluri are you talking about case when if any of the fk fields is null, then there doesn't have to be a parent record?  because otherwise 0 ... m is not a FK constraint???

Jasmin Fluri
  Sep 17th at 12:03 PM
Exactly. The 0 applies to the FK field that can be null. Hence an optional one-to-many relationship of the FK.
:+1:
1

Patrick Jolliffe
  Sep 17th at 2:22 PM
yep, and something i didn't realize until i started looking is that if it's a fk on multiple-columns, the 0..m is possible even if only one column is null, the others can be non-null and it doesn't enforce the existence of a parent record...
:100:
1

Kim Berg Hansen
  Sep 17th at 3:58 PM
Diff between 0..m or 1..m:
I wouldn't call it just additional information on the ERD. Even though the FK creation is identical, I'd say that a 0..m implies the FK field allows nulls, the 1..m implies the FK field is not null.
I'd say it's an error in the model if you say 0..m on a not null FK field or vice versa say 1..m on a nullable FK field.
I guess in modelling you could choose between:
a) specifying the FK field as nullable or not null and then simply state there's an FK relation (not needing to say 0..m or 1..m as that's implied from the nullability.)
or b) specifying 0..m or 1..m and then not needing to specify nullability as that's implied from either 0 or 1.
But what you pick would probably depend on what the modelling tool allows. If drawing ERD with paper and pen, anything goes :innocent:
:+1:
1

Jeff Smith
  Sep 17th at 4:43 PM
a philosophical/tech mix why they make sense in the first place, displace generalizations they hurt performance/don't scale - keep your logic in the app where they belong!
controversy fills those seats :slightly_smiling_face:
:pray:
1

Ilmar Kerm
  Sep 17th at 4:58 PM
Old classic - when exactly are indexes on FK-s needed and when not :slightly_smiling_face: Some query transformations that are possible only if FK is present.
:+1:
3
:pray:
1

Connor McDonald
  Sep 20th at 11:32 AM
"on update set null" ... a rarely used option.
"update cascade" ... not directly supported, but a trigger based implementation is on asktom
:+1:
1

Kim Berg Hansen
  Sep 20th at 1:13 PM
Just used “on update set null” this week. :grin:


Franck Pachot
  Sep 22nd at 5:07 PM
Regarding foreign keys and locks, I have an old Prezi (and I have some updates in newer versions if you need, but they are minimal). 
This is what is overlooked by "enforce in application" - the database can lock lower and shorter.
One crucial point today is about limitations with sharding (no cross-shard foreign keys).
This is where the "don't scale" comes from - most scale-out solutions have limitations on foreign keys
https://prezi.com/uzdd5ttg4cu0/indexing-foreign-keys-in-oracle/








